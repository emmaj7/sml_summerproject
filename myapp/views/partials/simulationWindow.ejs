<!--
Code for the simulation window.
Mikael Glamheden
2019-06-24
-->

<!-- Uses pixi module for the animation. Socket for the communication with server. -->
<script src="../node_modules/pixi.js/dist/pixi.min.js"></script>
<script src="../node_modules/socket.io-client/dist/socket.io.js"></script>
<script src="https://code.jquery.com/jquery-1.11.1.js"></script>
<div>
    <!-- <button onclick="runCar()" type="button">Starta simuleringen</button> -->
    <!-- <h1>Simulation Window</h1> -->

</div>
<div>
  <script type="text/javascript">
  /*----------------
  THE ANIMATION PART
  ----------------*/
  let type = "WebGL";
  if(!PIXI.utils.isWebGLSupported()){
    type = "canvas"
  }
  PIXI.utils.sayHello(type); // prints to console if everything is working.
  //Aliases
  let Application = PIXI.Application,
  loader = PIXI.loader,
  resources = PIXI.loader.resources,
  TextureCache = PIXI.utils.TextureCache,
  Sprite = PIXI.Sprite,
  Rectangle = PIXI.Rectangle;
  //Create a Pixi Application
  let app = new Application({
    width: 800,         // default: 800
    height: 800,        // default: 600
    antialias: true,    // default: false
    transparent: false, // default: false
    resolution: 1,      // default: 1
    forceCanvas: false  // force to use drawng API instead of WebGL
  });

  // Change background color
  app.renderer.backgroundColor = 0x0DA765B;
  // access style of window
  app.renderer.view.style.position = "absolute";
  app.renderer.view.style.left = '945px';
  app.renderer.view.style.top = '75px';
  //Add the canvas that Pixi automatically created for you to the HTML document
  document.body.appendChild(app.view);
  // Variables for the simulation
  let car; // object for car sprite
  let hitbox; // hitbox / shadow of car.
  let x_offset = 0.3;
  let y_offset = 0.4; // starting offset of car from lower left corner.
  let real_length = 3; // length of map in meters.
  let scale_factor = app.renderer.view.height/real_length;
  let last_yaw = 0;
  let dt = 1/30;
  let max = real_length/2;
  let start_coords = {'x': -max + x_offset,'y': -max + y_offset, 'yaw': 0}; // possibly move to level pages.
  let x = start_coords.x;
  let y = start_coords.y;
  let yaw = start_coords.yaw;
  let marg = 0.2; // margin to goal that counts as reached.
  let text0, text1, text2, text3, text4; // holds the 5 car sprite textures.
  let curr_sprite; // current displayed texture nr
  let obstacleHit = false;
  let wallHit = false;
  let obstacles = [];
  //load an image and run the `setup` function when it's done
  loader
  .add(['./images/svea_car.png',
        './images/svea_cars2.png',
        './images/mars-background2.png',
        './images/crater.png',
        './images/base-v2.png',
        './images/circle.png',
        './images/cross.png',
        './images/stone.png',
        './images/rectangle.png'])
  .load(setup);
  // This `setup` function will run when the image has loaded
  function resize_image(image){
    let imageRatio = image.width / image.height;
    let containerRatio = app.renderer.view.width / app.renderer.view.height;

    if (containerRatio > imageRatio) {
    	image.height = image.height / (image.width / app.renderer.view.width);
    	image.width = app.renderer.view.width;
    	image.position.x = 0;
    	image.position.y = (app.renderer.view.height - image.height) / 2;
    } else {
    	image.width = image.width / (image.height / app.renderer.view.height);
    	image.height = app.renderer.view.height;
    	image.position.y = 0;
    	image.position.x = (app.renderer.view.width - image.width) / 2;
    }
    return image;
  }
  function setup() {
    // Create the textures
    let rectangle0 = new Rectangle(0, 288*0, 413, 288);
    text0 = new PIXI.Texture(resources["./images/svea_cars2.png"].texture, rectangle0);
    let rectangle1 = new Rectangle(0, 288*1, 413, 288);
    text1 = new PIXI.Texture(resources["./images/svea_cars2.png"].texture, rectangle1);
    let rectangle2 = new Rectangle(0, 288*2, 413, 288);
    text2 = new PIXI.Texture(resources["./images/svea_cars2.png"].texture, rectangle2);
    let rectangle3 = new Rectangle(0, 288*3, 413, 288);
    text3 = new PIXI.Texture(resources["./images/svea_cars2.png"].texture, rectangle3);
    let rectangle4 = new Rectangle(0, 288*4, 413, 288);
    text4 = new PIXI.Texture(resources["./images/svea_cars2.png"].texture, rectangle4);


    // Init background
    background = new Sprite(resources["./images/mars-background2.png"].texture);
    background = resize_image(background);
    app.stage.addChild(background);

    // init obstacles
    for (var i = 0; i < obstacle_coords.length; i++) {
      obstacle = new Sprite(resources["./images/rectangle.png"].texture);
      obstacle_drawing = new Sprite(resources["./images/stone.png"].texture);
      obstacle.scale.x = obstacle_coords[i].size;
      obstacle.scale.y = obstacle_coords[i].size;
      obstacle.anchor.x = 0.5; obstacle.anchor.y = 0.5;
      obstacle_drawing.scale.x = obstacle_coords[i].size;
      obstacle_drawing.scale.y =  obstacle_coords[i].size;
      obstacle_drawing.anchor.x = 0.5; obstacle_drawing.anchor.y = 0.5;
      obstaclePx = coordinateTransform(obstacle_coords[i].x,
                                        obstacle_coords[i].y,
                                        obstacle_coords[i].yaw);
      obstacle.position.set(obstaclePx.x, obstaclePx .y);
      obstacle_drawing.position.set(obstaclePx.x, obstaclePx .y);
      obstacle_drawing.rotation = obstaclePx.yaw;

      obstacle.visible = true;
      app.stage.addChild(obstacle);
      app.stage.addChild(obstacle_drawing);
      obstacles.push(obstacle);
    }

    // Init goal
    goal = new Sprite(resources["./images/base-v2.png"].texture);
    goal.scale.x = 0.4; goal.scale.y = 0.4;
    goal.anchor.x = 0.5; goal.anchor.y = 0.6;
    goalPx = coordinateTransform(goal_coords.x, goal_coords.y, goal_coords.yaw);
    goal.position.set(goalPx.x,goalPx.y);
    app.stage.addChild(goal);
    cross = new Sprite(resources["./images/cross.png"].texture);
    cross.scale.x = 0.4; cross.scale.y = 0.4;
    cross.anchor.x = 0.5; cross.anchor.y = 0.5;
    goalPx = coordinateTransform(goal_coords.x, goal_coords.y, goal_coords.yaw);
    cross.position.set(goalPx.x,goalPx.y);
    app.stage.addChild(cross);

    // Init car and hitbox.
    curr_sprite = 2; // starting texture for car.
    car = new Sprite(text2);
    car.scale.x = 3*(90/app.renderer.width); car.scale.y = 3*(90/app.renderer.height);
    car.anchor.x = 0.5; car.anchor.y = 0.5;
    startPx = coordinateTransform(start_coords.x, start_coords.y, start_coords.yaw);
    car.position.set(startPx.x,startPx.y);
    car.rotation = startPx.yaw;


    hitbox = new Sprite(resources["./images/circle.png"].texture);
    hitbox.anchor.x = 0.5; hitbox.anchor.y = 0.5;
    hitbox.height = car.height - 30; hitbox.width = car.width;
    hitbox.position.set(startPx.x,startPx.y);
    hitbox.visible = true; // hitbox visible/not visible

    app.stage.addChild(hitbox);
    app.stage.addChild(car);
  }
  </script>
</div>
<div>
  <script type="text/javascript">
    // transforms between "true" coordinate system and browser window coordinates
    function coordinateTransform(x, y, yaw){
      let coords = {};
      coords.x = scale_factor*(x + max);
      coords.y = app.renderer.view.height - scale_factor*(y + max); // y = 0 is upper corner
      coords.yaw = -yaw;
      return coords;
    }
    function transformReversed(x, y, yaw){
      let coords = {};
      coords.x = x/scale_factor - max;
      coords.y = -(y - app.renderer.view.height)/scale_factor - max;
      coords.yaw = -yaw;
      return coords;
    };
    // swithc wich sprite to display.
    function changeSprite(i){
      if (i === 0) {
        car.texture = text0;
      } else if (i === 1) {
        car.texture = text1;
      } else if (i === 2) {
        car.texture = text2;
      } else if (i === 3) {
        car.texture = text3;
      } else if (i === 4) {
        car.texture = text4;
      }
    }
    // Checks if x between min and max.
    function between(x, min, max) {
      return x >= min && x <= max;
    }
    // decides which sprite to display
    function newSprite(yaw, curr_sprite){
      let res = new Object();
      res.value = false;
      res.sprite = curr_sprite;
      d_yaw = (yaw-last_yaw)/dt;
      if (between(d_yaw,-0.05, 0.05)) {
        if (curr_sprite !== 2) {
          res.value = true; res.sprite = 2;
          curr_sprite = 2;
        }
      } else if (between(d_yaw, 0.05, 0.3)) {
        if (curr_sprite !== 1) {
          res.value = true; res.sprite = 1;
          curr_sprite = 1;
        }
      } else if (between(d_yaw, 0.3, 0.6)) {
        if (curr_sprite !== 0) {
          res.value = true; res.sprite = 0;
          curr_sprite = 0;
        }
      } else if (between(d_yaw, -0.3, -0.05)) {
        if (curr_sprite !== 3) {
          res.value = true; res.sprite = 3;
          curr_sprite = 3;
        }
      } else if (between(d_yaw, -0.6, -0.3)) {
        if (curr_sprite !== 4) {
          res.value = true; res.sprite = 4;
          curr_sprite = 4;
        }
      }
      return res;
    }
    // updates position of car.
    function drive(){
      // console.log(hitbox.width);
      let coords = coordinateTransform(x, y, yaw);
      car.position.set(coords.x, coords.y);
      car.rotation = coords.yaw;
      hitbox.position.set(coords.x, coords.y);
      hitbox.rotation = coords.yaw;
      let response = newSprite(yaw, curr_sprite);
      if (response.value) {
        changeSprite(response.sprite);
      }
      // Check for obstacle collision
      for (var i = 0; i < obstacles.length; i++) {
        if (collision(hitbox, obstacles[i])) {
          obstacleHit = true;
        }
      }
      // check for collision with map edge
      if (edgeCollision(hitbox)){
        wallHit = true
      }
    }
    // Checks if car is at goal.
    function atGoal(){
      // checks if car is at goal.
      let dist = Math.sqrt(Math.pow(x-goal_coords.x,2) + Math.pow(y-goal_coords.y,2));
      if (dist < marg){
          return true;
      } else {
        return false;
      }
    }
    // Checks for collision with map edges.
    function edgeCollision(sprite){
      let hit, vx, vy, wall;
      wall = {};
      hit = false;
      //Find the half-heights of the sprite. (the shortest distance)
      sprite.halfHeight = sprite.height / 2;

      // Get limits of map
      wall.xmax = app.renderer.view.width;
      wall.xmin = 0;
      wall.ymin = 0;
      wall.ymax = app.renderer.view.height;

      // Check for collisions with map border.
      if (Math.abs(sprite.x-wall.xmax) < sprite.halfHeight){
        console.log('Hit 1');
        hit = true;
      } else if (Math.abs(sprite.x-wall.xmin) < sprite.halfHeight){
        console.log('Hit 2');
        hit = true;
      } else if (Math.abs(sprite.y-wall.ymax) < sprite.halfHeight) {
        console.log('Hit 3');
        console.log('HalfHeight: ', sprite.halfHeight);
        console.log('Distance: ', Math.abs(sprite.y-wall.ymax));
        console.log('Coords:', sprite.x, sprite.y);
        hit = true;
      } else if (Math.abs(sprite.y-wall.ymin) < sprite.halfHeight) {
        console.log('Hit 4');
        hit = true;
      }
      return hit;
    }
    function getAxisNormal(ps,i){
      // returns vecot perpendicular to side i of polygon.
      if (i === ps.length - 1) {
        p1 = ps[i]
        p2 = ps[1];
      } else {
        let p1 = ps[i];
        let p2 = ps[i + 1];
      }
      // b is unit vector perpendicular to one edge of r1 with lenght 1
      let v = [p1[0]-p2[0], p1[1]-p2[1]];
      v = [1, -v[0]/v[1]];
      let b = [0,0];
      b[0] = v[0]/Math.sqrt(Math.pow(v[0],2) + Math.pow(v[1],2));
      b[1] = v[1]/Math.sqrt(Math.pow(v[0],2) + Math.pow(v[1],2));
      return b;
    }
    // checks for collision between two sprites
    function collision(r1, r2) {
      let realc1 = transformReversed(r1.x, r1.y, r1.rotation);
      let realc2 = transformReversed(r2.x, r2.y, r2.rotation);

      // corner points of r1
      w1 = r1.width/scale_factor; h1 = r1.height/scale_factor;
      phi1 = realc1.yaw;
      p1 = [realc1.x + (w1/2)*Math.cos(phi1) - (h1/2)*Math.sin(phi1),
            realc1.y + (w1/2)*Math.sin(phi1) + (h1/2)*Math.cos(phi1)];
      p2 = [realc1.x + (w1/2)*Math.cos(phi1) + (h1/2)*Math.sin(phi1),
            realc1.y + (w1/2)*Math.sin(phi1) - (h1/2)*Math.cos(phi1)];
      p3 = [realc1.x - (w1/2)*Math.cos(phi1) - (h1/2)*Math.sin(phi1),
            realc1.y - (w1/2)*Math.sin(phi1) + (h1/2)*Math.cos(phi1)];
      p4 = [realc1.x - (w1/2)*Math.cos(phi1) + (h1/2)*Math.sin(phi1),
            realc1.y - (w1/2)*Math.sin(phi1) - (h1/2)*Math.cos(phi1)];
      corners_r1 = [p1, p2, p3, p4];

      // corner points of r2
      w2 = r2.width/scale_factor; h2 = r2.height/scale_factor;
      phi2 = realc2.yaw;
      q1 = [realc2.x + (w2/2)*Math.cos(phi2) - (h2/2)*Math.sin(phi2),
            realc2.y + (w2/2)*Math.sin(phi2) + (h2/2)*Math.cos(phi2)];
      q2 = [realc2.x + (w2/2)*Math.cos(phi2) + (h2/2)*Math.sin(phi2),
            realc2.y + (w2/2)*Math.sin(phi2) - (h2/2)*Math.cos(phi2)];
      q3 = [realc2.x - (w2/2)*Math.cos(phi2) - (h2/2)*Math.sin(phi2),
            realc2.y - (w2/2)*Math.sin(phi2) + (h2/2)*Math.cos(phi2)];
      q4 = [realc2.x - (w2/2)*Math.cos(phi2) + (h2/2)*Math.sin(phi2),
            realc2.y - (w2/2)*Math.sin(phi2) - (h2/2)*Math.cos(phi2)];
      corners_r2 = [q1, q2, q3, q4];
      for (var i = 0; i < corners_r1.length; i++) {
        let b = getAxisNormal(corners_r1,i);
        // console.log('b', b);
        let proj_r1 = []; // corners of r1 projected on b
        for (var j = 0; j < corners_r1.length; j++) {
          let a = b[0]*corners_r1[j][0] + b[1]*corners_r1[j][1];
          proj_r1.push(a);
        }

        let proj_r2 = []; // corners of r2 projected on b
        for (var j = 0; j < corners_r2.length; j++) {
          let a = b[0]*corners_r2[j][0] + b[1]*corners_r2[j][1];
          proj_r2.push(a);
        }

        max1 = Math.max(...proj_r1);
        min1 = Math.min(...proj_r1);
        max2 = Math.max(...proj_r2);
        min2 = Math.min(...proj_r2);

        d1 = min1 - max2;
        d2 = min2 - max1;
        if (d1 > 0 || d2 > 0){
          //  console.log('false');
          return false;
        }
      }
      // console.log('true');
      return true;
    }
    function collisionOld(r1, r2) {
      //Define the variables we'll need to calculate
      let hit, combinedHalfWidths, combinedHalfHeights, vx, vy;
      //hit will determine whether there's a collision
      hit = false;
      //Find the half-widths and half-heights of each sprite
      r1.halfWidth = r1.width / 2;
      r1.halfHeight = r1.height / 2;
      r2.halfWidth = r2.width / 2;
      r2.halfHeight = r2.height / 2;
      //Calculate the distance vector between the sprites
      vx = r1.x - r2.x;
      vy = r1.y - r2.y;
      //Figure out the combined half-widths and half-heights
      combinedHalfWidths = r1.halfWidth + r2.halfWidth;
      combinedHalfHeights = r1.halfHeight + r2.halfHeight;
      //Check for a collision on the x axis
      if (Math.abs(vx) < combinedHalfWidths) {
        //A collision might be occurring. Check for a collision on the y axis
        if (Math.abs(vy) < combinedHalfHeights) {
          //There's definitely a collision happening
          hit = true;
        } else {
          //There's no collision on the y axis
          hit = false;
        }
      } else {
        //There's no collision on the x axis
        hit = false;2
      }
      //`hit` will be either `true` or `false`
      return hit;
    };

    // Called when run code button pressed.
    function runSimulation(onCar){
      app.ticker.start()
      var socket = io();
      curr_sprite = 5;
      obstacleHit = false;
      wallHit = false;
      x = start_coords.x;
      y = start_coords.y;
      yaw = start_coords.yaw;

      // start two-way communication
      socket.on('connect',function(){
        console.log('Connected');
        console.log('Session id: ' + unique_id); // Unique id for each html page opened.
        if (onCar){
          socket.emit('runCodeOnCar', JSON.stringify({'id': unique_id,
                                                      'goal': goal_coords}));
          console.log('Running code on car');
        } else {
          socket.emit('simulationOnly', JSON.stringify({'id': unique_id,
                                                        'start': start_coords,
                                                        'goal': goal_coords}));
          console.log('starting simulation');
          runningSimulation = true;
          whichButton();
          //dölj kör - visa cancel
        }
      });2
      // recieves position. Updates car position in simulation.
      socket.on('position-sent-car', function(msg){
        if(onCar){
          let = JSON.parse(msg);
          x = obj.x;
          y = obj.y;
          last_yaw = yaw;
          yaw = obj.yaw;
        }
      });
      // recieves position. Updates car position in simulation.
      socket.on('position-sent-sim', function(msg){
        if (onCar == false){
          let obj = JSON.parse(msg);
          x = obj.x;
          y = obj.y;
          last_yaw = yaw;
          yaw = obj.yaw;

          if (obstacleHit || wallHit){
            socket.emit('collision');
            console.log('Collision!');
          }
          if (cancel_simulation){
            console.log('cancelling simulation');
            socket.emit('cancel-simulation');
            cancel_simulation = false;
          }
        }
      });
      // Called when python script is closed. Either forced or natural.
      socket.on('close', function(forced_close){
        app.ticker.stop();
        console.log()
        console.log('Connection closed');
        socket.disconnect(true); // close connection to server.
        at_goal = atGoal(); // variable from level.
        console.log('At goal: ' + at_goal.toString());
        document.getElementById('modal');

        if (at_goal.toString() === 'true'){ // Completed level 1
          runningSimulation = false;
          whichButton();
          if (level === 1){
            var modal1 = document.getElementById('myModal1');
            modal1.style.display = "block";
            window.onclick = function(event) {
              if (event.target == modal1) {
                modal1.style.display = "none";
              }
            }
          } else if (level === 2){ // Completed level 2
            var modal2 = document.getElementById('myModal2');
            modal2.style.display = "block";
            window.onclick = function(event) {
              if (event.target == modal2) {
                modal2.style.display = "none";
              }
            }
          } else if (level === 3){ // Completed level 3
            var modal3 = document.getElementById('myModal3');
            modal3.style.display = "block";
            window.onclick = function(event) {
              if (event.target == modal3) {
                modal3.style.display = "none";
              }
            }
          }
        } else if (obstacleHit) { // Hit obstacle on either level
          var tryAgainBtn = document.getElementById('restartBtn');
          var hitModal = document.getElementById('myHitModal');
          hitModal.style.display = "block";
          tryAgainBtn.onclick = function() {
            hitModal.style.display = "none";
            runningSimulation = false;
            whichButton();
          }
          window.onclick = function(event) {
            if (event.target == hitModal) {
              hitModal.style.display = "none";
              runningSimulation = false;
              whichButton();
            }
          }
        } else if (wallHit) { // Hit wall on either level
          var tryAgainBtn = document.getElementById('restart2Btn');
          var wallModal = document.getElementById('myWallModal');
          wallModal.style.display = "block";
          tryAgainBtn.onclick = function() {
            wallModal.style.display = "none";
            runningSimulation = false;
            whichButton();
          }
          window.onclick = function(event) {
            if (event.target == wallModal) {
              wallModal.style.display = "none";
              runningSimulation = false;
              whichButton();
            }
          }
        } else {
            if (forced_close) {
              // Do nothing
            runningSimulation = false;
          whichButton();
          } else { // Did not reach goal
            var tryAgainBtn = document.getElementById('tryAgainBtn');
            var tryAgainModal = document.getElementById('myTryAgainModal');
            tryAgainModal.style.display = "block";
            tryAgainBtn.onclick = function() {
              tryAgainModal.style.display = "none";
              runningSimulation = false;
              whichButton();
            }
            window.onclick = function(event) {
              if (event.target == tryAgainModal) {
                tryAgainModal.style.display = "none";
                runningSimulation = false;
                whichButton();
              }
            }
          }
        }
      });

      // This function is run at 60 Hz. Defined by app.ticker.
      app.ticker.add(delta => drive(delta));
    }

  </script>
</div>
