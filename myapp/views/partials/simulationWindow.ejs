<!--
Code for the simulation window.
Mikael Glamheden
2019-06-24
-->

<!--
TO DO:
  - Arrange windows and buttons in a nice way.
  - Make level 1-3.
-->

<!-- Uses pixi module for the animation. Socket for the communication with server. -->
<script src="../node_modules/pixi.js/dist/pixi.min.js"></script>
<script src="../node_modules/socket.io-client/dist/socket.io.js"></script>
<script src="https://code.jquery.com/jquery-1.11.1.js"></script>
<div>
    <!-- <button onclick="runCar()" type="button">Starta simuleringen</button> -->
    <!-- <h1>Simulation Window</h1> -->

</div>
<div>
  <script type="text/javascript">
  /*----------------
  THE ANIMATION PART
  ----------------*/
  let type = "WebGL";
  if(!PIXI.utils.isWebGLSupported()){
    type = "canvas"
  }
  PIXI.utils.sayHello(type); // prints to console if everything is working.
  //Aliases
  let Application = PIXI.Application,
  loader = PIXI.loader,
  resources = PIXI.loader.resources,
  TextureCache = PIXI.utils.TextureCache,
  Sprite = PIXI.Sprite,
  Rectangle = PIXI.Rectangle;
  //Create a Pixi Application
  var window_size = 600;
  let app = new Application({
    width: window_size,         // default: 800
    height: window_size,        // default: 600
    antialias: true,    // default: false
    transparent: false, // default: false
    resolution: 1,      // default: 1
    forceCanvas: false  // force to use drawng API instead of WebGL
  });
  // Change background color
  app.renderer.backgroundColor = 0x061639;
  // access style of window
  app.renderer.view.style.position = "absolute";
  app.renderer.view.style.left = '800px';
  app.renderer.view.style.top = '120px';
  //Add the canvas that Pixi automatically created for you to the HTML document
  document.body.appendChild(app.view);
  // Variables for the simulation
  let car;
  var PI = Math.PI;
  var x_offset = 40;
  var y_offset = -40;
  var scale_factor = 256/2;
  var x = 0;
  var y = 0;
  var yaw = 0;
  let last_yaw = 0;
  let dt = 1/30;
  var xp;
  var yp;
  var obj;
  var max = 1.5;
  var start = {'x': -max,'y': -max, 'yaw': 0};
  var marg = 0.1;
  let text0, text1, text2, text3, text4;
  let curr_sprite;
  //load an image and run the `setup` function when it's done
  loader
  .add(['./images/svea_car.png','./images/svea_cars2.png',
        './images/cross.png'])
  .load(setup);
  // This `setup` function will run when the image has loaded
  function setup() {
    // Create the textures
    cross = new Sprite(resources["./images/cross.png"].texture);
    let rectangle0 = new Rectangle(0, 288*0, 413, 288);
    text0 = new PIXI.Texture(resources["./images/svea_cars2.png"].texture, rectangle0);
    let rectangle1 = new Rectangle(0, 288*1, 413, 288);
    text1 = new PIXI.Texture(resources["./images/svea_cars2.png"].texture, rectangle1);
    let rectangle2 = new Rectangle(0, 288*2, 413, 288);
    text2 = new PIXI.Texture(resources["./images/svea_cars2.png"].texture, rectangle2);
    let rectangle3 = new Rectangle(0, 288*3, 413, 288);
    text3 = new PIXI.Texture(resources["./images/svea_cars2.png"].texture, rectangle3);
    let rectangle4 = new Rectangle(0, 288*4, 413, 288);
    text4 = new PIXI.Texture(resources["./images/svea_cars2.png"].texture, rectangle4);
    // Create the car sprite
    car = new Sprite(text2);
    curr_sprite = 2;
    // Change the sprite's size
    car.scale.x = 0.2; car.scale.y = 0.2;
    cross.scale.x = 0.8; cross.scale.y = 0.8;
    // change anchor point
    car.anchor.x = 0.5; car.anchor.y = 0.5;
    cross.anchor.x = 0.5; cross.anchor.y = 0.5;
    // put in right position
    start = coordinate_transform(start.x, start.y, start.yaw);
    goalPx = coordinate_transform(goal.x, goal.y, goal.yaw);
    car.position.set(start.x,start.y);
    car.rotation = start.yaw;
    cross.position.set(goalPx.x,goalPx.y);
    // Add the sprites to the stage
    app.stage.addChild(cross);
    app.stage.addChild(car);
  }
  </script>
</div>
<div>
  <script type="text/javascript">
    // transforms between "true" coordinate system and browser window coordinates
    function coordinate_transform(x, y, yaw){
      var coords = {};
      coords.x = scale_factor*(x + max) + x_offset;
      coords.y = window_size - scale_factor*(y + max) + y_offset; // y = 0 is upper corner
      coords.yaw = -yaw;
      return coords;
    }
    // swithc wich sprite to display.
    function change_sprite(i){
      if (i === 0) {
        car.texture = text0;
      } else if (i === 1) {
        car.texture = text1;
      } else if (i === 2) {
        car.texture = text2;
      } else if (i === 3) {
        car.texture = text3;
      } else if (i === 4) {
        car.texture = text4;
      }
    }
    // Checks if x between min and max.
    function between(x, min, max) {
      return x >= min && x <= max;
    }
    // decides which sprite to display
    function new_sprite(yaw, curr_sprite){
      var res = new Object();
      res.value = false;
      res.sprite = curr_sprite;
      d_yaw = (yaw-last_yaw)/dt;
      if (between(d_yaw,-0.05, 0.05)) {
        if (curr_sprite !== 2) {
          res.value = true; res.sprite = 2;
          curr_sprite = 2;
        }
      } else if (between(d_yaw, 0.05, 0.3)) {
        if (curr_sprite !== 1) {
          res.value = true; res.sprite = 1;
          curr_sprite = 1;
        }
      } else if (between(d_yaw, 0.3, 0.6)) {
        if (curr_sprite !== 0) {
          res.value = true; res.sprite = 0;
          curr_sprite = 0;
        }
      } else if (between(d_yaw, -0.3, -0.05)) {
        if (curr_sprite !== 3) {
          res.value = true; res.sprite = 3;
          curr_sprite = 3;
        }
      } else if (between(d_yaw, -0.6, -0.3)) {
        if (curr_sprite !== 4) {
          res.value = true; res.sprite = 4;
          curr_sprite = 4;
        }
      }
      return res;
    }
    // updates position of car.
    function drive(){
      var coords = coordinate_transform(x, y, yaw);
      car.position.set(coords.x, coords.y);
      car.rotation = coords.yaw;
      // console.log(yaw);
      let response = new_sprite(yaw, curr_sprite);
      if (response.value) {
        change_sprite(response.sprite);
      }
    }
    // Checks if car is at goal.
    function atGoal(){
      // checks if car is at goal.
      var dist = Math.sqrt(Math.pow(x-goal.x,2) + Math.pow(y-goal.y,2));
      if (dist < marg){
          return true;
      } else {
        return false;
      }
    }
    // Called when run code button pressed.
    function runSimulation(onCar){
      app.ticker.start()
      var socket = io();
      curr_sprite = 5;
      // start two-way communication
      socket.on('connect',function(){
        console.log('Connected');
        console.log('Session id: ' + unique_id); // Unique id for each html page opened.
        if (onCar){
          socket.emit('runCodeOnCar', JSON.stringify({'id': unique_id, 'goal': goal}));
          console.log('Running code on car');
        } else {
          socket.emit('simulationOnly', JSON.stringify({'id': unique_id, 'goal': goal}));
          console.log('starting simulation');
        }
      });
      // recieves position. Updates car position in simulation.
      socket.on('position-sent-car', function(msg){
        if(onCar){
          obj = JSON.parse(msg);
          x = obj.x;
          y = obj.y;
          last_yaw = yaw;
          yaw = obj.yaw;
        }
      });
      socket.on('position-sent-sim', function(msg){
        if (onCar == false){
          obj = JSON.parse(msg);
          x = obj.x;
          y = obj.y;
          last_yaw = yaw;
          yaw = obj.yaw;
        }
      });
      socket.on('close', function(){
        app.ticker.stop();
        console.log('Connection closed');
        socket.disconnect(true); // close connection to server.
        at_goal = atGoal(); // variable from level.
        console.log('At goal: ' + at_goal.toString());
        if (at_goal.toString() === 'true'){
          alert("Grattis!")
        }
        else {
          alert("Testa igen!")
        }
      });
      // This function is run at 60 Hz. Defined by app.ticker.
      app.ticker.add(delta => drive(delta));
    }

  </script>
</div>
